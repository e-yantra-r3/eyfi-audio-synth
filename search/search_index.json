{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"eYFi-Mega based Audio Synthesizer Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas Abstract The objective of this project is to develop an Audio Synthesizer and Spectrum Analyzer using eYFi-Mega development board . Audio Synthesizer Now let us dive into world of audio processing techniques where we will learn most commonly used terms and components which are required in analog based audio synthesis . The practical demonstration of our project will be in digitally generated sound,But let us get a glimpse of what audio synthesis is Audio Synthesizer is an electronic musical instrument that generates audio signals. Synthesizers generate audio through methods including subtractive synthesis, additive synthesis, and frequency modulation synthesis. Synthesizers are typically played with keyboards or controlled by sequencers, software, or other instruments, often via MIDI. I: Oscillator If anything is the heart of a synthesizer then it will be its oscillator. It produces a raw, unfiltered sound wave. An oscillator will generate a saw wave, square wave, sine wave, triangle wave, or noise. In digital synthesizers, the core of the oscillator can be a wavetable ( predefined set of values ) or even a recorded sample. The sound sample below is a saw wave, the way you would hear it if you directly tapped the audio output of an analog oscillator. Here in our demonstration we have generated musical tones wavetable with 8-bit configuration . II: Amplifier Every synthesizer has an amplifier, or more accurately, a variety of amplifiers. Often seen abbreviated as VCA (voltage-controlled amplifier) and DCA (digitally controlled amplifier) , the amplifiers are the components that determine exactly how much signal from the oscillator gets passed on to the next part of the synthesizer. The name amplifier is a bit misleading and confusing, though. Technically speaking, an amplifier is part of a circuit that boosts signal, but in synthesizers, the amplifier actually attenuates, or reduces, any signal coming through it. In most analog and analog-modeling synthesizers, each oscillator is fed into an amplifier that keeps the oscillator signal completely attenuated until the amplifier is stimulated by an incoming control voltage (CV) . That way, we only hear the oscillator when the amplifier is activated somehow. That\u2019s how we get separation between notes rather than a constant tone. Synthesizers have a keyboard that generates a gate signal when a key is pressed, which triggers an envelope , which then stimulates the amplifier to allow signal to pass through. Here\u2019s what that sounds like, if you were to tap the output of an amplifier that is responding to a gate signal generated by a keyboard or a sequencer. III: Filter In the context of a synthesizer, a filter is a module that removes certain frequencies from the audio signal, much like an equalizer on a stereo or a recording console. The most commonly found filter types on an analog synthesizer are lowpass (LP) filters, which filter out high frequencies and let low frequencies pass (hence the name) and highpass (HP) filters, which filter out low frequencies and allow high frequencies to pass. You may also see bandpass (BP) and all-pass filters on certain synthesizer. Filters are used to alter the timbre or tone of a sound. Minimally, a synthesizer will give you control over the cutoff frequency of the filter (the frequency at which the filter starts cutting off) and the resonance of the filter, which is a boost or bump that occurs at the cutoff frequency. IV: Envelope An envelope generator is a module that alters incoming voltage over time. This can be used in a lot of ways, such as to open up an amplifier circuit in order to give a volume contour to a sound. Listen to the difference between an oscillator going through an amplifier circuit that\u2019s simply being opened and closed by a gate signal. compared with an oscillator going through an amplifier circuit that\u2019s being opened and closed by an envelope generator that\u2019s reacting to that same gate signal. Most synthesizers have multiple envelope generators \u2014 minimally one that controls the amplifier, and thus the volume of each note over time, and one that controls the filter and the frequency content of each note over time. However, some synthesizers, specifically modular synthesizers, allow you to patch envelope generators into practically anything. When it comes to envelopes, they come in many shapes and sizes, but most frequently you\u2019ll see envelopes represented by the letters ADSR when they appear on synthesizers. A: Attack . This is the time it takes for the envelope to reach its maximum value after the note begins its attack. D: Decay . This is the time it takes for the envelope to fall from maximum value to the sustain level. The decay stage does a lot to define whether a sound is snappy and transient or long and flowing. S: Sustain . This one is tricky, because it\u2019s the only part of the envelope that\u2019s a measure of amplitude rather than time. The sustain level is the value at which the envelope rests after the decay stage, until the key is released. This is often expressed as a percentage of maximum value. When it comes to amplitude and filter envelopes, patches emulating plucked or struck instruments like drums or mallets would have zero sustain. Bowed instruments and brass and woodwind sounds, on the other hand, would have a higher sustain value. R: Release . Release is the time it takes for the envelope to fall back to zero after the key is released (or technically, after the gate signal ends). Think of an acoustic guitar \u2014 this instrument would have a very sharp attack, a short decay stage, zero sustain, but a long release when strummed as the strings slowly lose energy and volume. On the other hand, a marimba would have a much shorter release time. An aggressive modern synth bass or lead patch might have essentially zero release. What is Gate and Trig ? Gate signal tells the synthesizer when a note starts and when it ends. Here\u2019s an example \u2014 a keyboard can generate a gate signal, which begins when the key is pressed and ends when the key is released. A sequencer could generate gate signals, and it could have various ways of controlling the length of the signal (and thus the length of the note, provided that the gate signal is patched to the gate input of an envelope generator that\u2019s connected to the CV input of an amplifier). Trig stands for trigger. A trigger resembles a gate signal, but instead of having an element of time to it, it\u2019s instantaneous. Put another way, a gate opens at one time and closes later, for instance, when you take your hand off a key. A trigger signal is an instantaneous pulse. For this reason, trigger signal is seen frequently on analog sequencers designed to drive drum machines and isn\u2019t as suitable for melodic instruments.","title":"**eYFi-Mega based Audio Synthesizer**"},{"location":"#eyfi-mega-based-audio-synthesizer","text":"Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas","title":"eYFi-Mega based Audio Synthesizer"},{"location":"#abstract","text":"The objective of this project is to develop an Audio Synthesizer and Spectrum Analyzer using eYFi-Mega development board .","title":"Abstract"},{"location":"#audio-synthesizer","text":"Now let us dive into world of audio processing techniques where we will learn most commonly used terms and components which are required in analog based audio synthesis . The practical demonstration of our project will be in digitally generated sound,But let us get a glimpse of what audio synthesis is Audio Synthesizer is an electronic musical instrument that generates audio signals. Synthesizers generate audio through methods including subtractive synthesis, additive synthesis, and frequency modulation synthesis. Synthesizers are typically played with keyboards or controlled by sequencers, software, or other instruments, often via MIDI.","title":"Audio Synthesizer"},{"location":"#i-oscillator","text":"If anything is the heart of a synthesizer then it will be its oscillator. It produces a raw, unfiltered sound wave. An oscillator will generate a saw wave, square wave, sine wave, triangle wave, or noise. In digital synthesizers, the core of the oscillator can be a wavetable ( predefined set of values ) or even a recorded sample. The sound sample below is a saw wave, the way you would hear it if you directly tapped the audio output of an analog oscillator. Here in our demonstration we have generated musical tones wavetable with 8-bit configuration .","title":"I: Oscillator"},{"location":"#ii-amplifier","text":"Every synthesizer has an amplifier, or more accurately, a variety of amplifiers. Often seen abbreviated as VCA (voltage-controlled amplifier) and DCA (digitally controlled amplifier) , the amplifiers are the components that determine exactly how much signal from the oscillator gets passed on to the next part of the synthesizer. The name amplifier is a bit misleading and confusing, though. Technically speaking, an amplifier is part of a circuit that boosts signal, but in synthesizers, the amplifier actually attenuates, or reduces, any signal coming through it. In most analog and analog-modeling synthesizers, each oscillator is fed into an amplifier that keeps the oscillator signal completely attenuated until the amplifier is stimulated by an incoming control voltage (CV) . That way, we only hear the oscillator when the amplifier is activated somehow. That\u2019s how we get separation between notes rather than a constant tone. Synthesizers have a keyboard that generates a gate signal when a key is pressed, which triggers an envelope , which then stimulates the amplifier to allow signal to pass through. Here\u2019s what that sounds like, if you were to tap the output of an amplifier that is responding to a gate signal generated by a keyboard or a sequencer.","title":"II: Amplifier"},{"location":"#iii-filter","text":"In the context of a synthesizer, a filter is a module that removes certain frequencies from the audio signal, much like an equalizer on a stereo or a recording console. The most commonly found filter types on an analog synthesizer are lowpass (LP) filters, which filter out high frequencies and let low frequencies pass (hence the name) and highpass (HP) filters, which filter out low frequencies and allow high frequencies to pass. You may also see bandpass (BP) and all-pass filters on certain synthesizer. Filters are used to alter the timbre or tone of a sound. Minimally, a synthesizer will give you control over the cutoff frequency of the filter (the frequency at which the filter starts cutting off) and the resonance of the filter, which is a boost or bump that occurs at the cutoff frequency.","title":"III: Filter"},{"location":"#iv-envelope","text":"An envelope generator is a module that alters incoming voltage over time. This can be used in a lot of ways, such as to open up an amplifier circuit in order to give a volume contour to a sound. Listen to the difference between an oscillator going through an amplifier circuit that\u2019s simply being opened and closed by a gate signal. compared with an oscillator going through an amplifier circuit that\u2019s being opened and closed by an envelope generator that\u2019s reacting to that same gate signal. Most synthesizers have multiple envelope generators \u2014 minimally one that controls the amplifier, and thus the volume of each note over time, and one that controls the filter and the frequency content of each note over time. However, some synthesizers, specifically modular synthesizers, allow you to patch envelope generators into practically anything. When it comes to envelopes, they come in many shapes and sizes, but most frequently you\u2019ll see envelopes represented by the letters ADSR when they appear on synthesizers. A: Attack . This is the time it takes for the envelope to reach its maximum value after the note begins its attack. D: Decay . This is the time it takes for the envelope to fall from maximum value to the sustain level. The decay stage does a lot to define whether a sound is snappy and transient or long and flowing. S: Sustain . This one is tricky, because it\u2019s the only part of the envelope that\u2019s a measure of amplitude rather than time. The sustain level is the value at which the envelope rests after the decay stage, until the key is released. This is often expressed as a percentage of maximum value. When it comes to amplitude and filter envelopes, patches emulating plucked or struck instruments like drums or mallets would have zero sustain. Bowed instruments and brass and woodwind sounds, on the other hand, would have a higher sustain value. R: Release . Release is the time it takes for the envelope to fall back to zero after the key is released (or technically, after the gate signal ends). Think of an acoustic guitar \u2014 this instrument would have a very sharp attack, a short decay stage, zero sustain, but a long release when strummed as the strings slowly lose energy and volume. On the other hand, a marimba would have a much shorter release time. An aggressive modern synth bass or lead patch might have essentially zero release.","title":"IV: Envelope"},{"location":"#what-is-gate-and-trig","text":"Gate signal tells the synthesizer when a note starts and when it ends. Here\u2019s an example \u2014 a keyboard can generate a gate signal, which begins when the key is pressed and ends when the key is released. A sequencer could generate gate signals, and it could have various ways of controlling the length of the signal (and thus the length of the note, provided that the gate signal is patched to the gate input of an envelope generator that\u2019s connected to the CV input of an amplifier). Trig stands for trigger. A trigger resembles a gate signal, but instead of having an element of time to it, it\u2019s instantaneous. Put another way, a gate opens at one time and closes later, for instance, when you take your hand off a key. A trigger signal is an instantaneous pulse. For this reason, trigger signal is seen frequently on analog sequencers designed to drive drum machines and isn\u2019t as suitable for melodic instruments.","title":"What is  Gate and Trig ?"},{"location":"01_introduction/","text":"eYFi-Mega based Audio Synthesizer Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas Introduction eYFi Mega based Audio Synthesizer is an Audio device project where we will create an audio synthesizer or in simple words audio generator. In this project we will be using 4x4 16 Key Universal Keypad and a speaker. Using Keypad we will generate different tones as programmed. eYFi Mega eYFi Mega Development board is an Atmega2560 and ESP32 based development board, made in India. This board is developed by eYantra at IIT Bombay. Key-points: Atmega2560 and ESP32 based WiFi Compatible FreeRTOS Compatible Arduino IDE suitable Audio Synthesizer A Audio Synthesizer is an electronic musical instrument that generates audio signals. Synthesizers generate audio through methods including subtractive synthesis, additive synthesis, and frequency modulation synthesis. Synthesizers are typically played with keyboards or controlled by sequencers, software, or other instruments, often via MIDI. Digital Signal Processing (DSP) Mathematical manipulation of Digial Signals like Audio, Video, Pressure, Temperature, etc is called as Digital Signal Processing (DSP) . It is the use of digital processing, such as by computers or more specialized digital signal processors, to perform a wide variety of signal processing operations. DSP can involve linear or nonlinear operations. Nonlinear signal processing is closely related to nonlinear system identification and can be implemented in the time, frequency, and spatio-temporal domains. About Sound Sounds are just vibrations, our ears pick up the vibrations from objects as they hit the air particles in front of them and the energy is passed on; air particle to air particle; until air particles in our ear pass on this vibrating energy to our ear drum and through some other clever nature stuff we convert this to electrical signals in our ear that the brain can interpret as sound. The pitch of a sound is the speed at which it vibrates, its frequency Sounds from vibrations produce sound waves and as such like other types of wave have certain properties, they two main ones we\u2019re interested in are the frequency which is how many times is that repeated and the amplitude is how much intensity is that having .An important thing to notice about the wave is that the amplitude changes over the time . It\u2019s not instant high then instant low. We can produce sounds like this and they are called square waves but in nature this type of sound waves are rare find We are using DAC Audio library to play (sa re ga ma pa da ne sa) tones which are stored as values between 0-65535 . It uses a digital to analogue interface, which are built into the ESP32 (but not Arduino\u2019s), hence why I chose that chip for the main development. This allows the relatively precise control over the final waveform. There are other ways of getting sound out of an ESP32, such as it\u2019s in-built support for I2S streaming. With this you can output digital sound to nearly any pin and with couple or so components you can get stereo sound out. Really quite cool. In the future the library will support this approach but for now it uses the DAC pin which reduces external components (admittedly very slightly) and I think conceptually it is easier for a beginner to see how sound could be produced that way. In any case that\u2019s the way the design was originally conceived!! What is a DAC ? In electronics, a digital-to-analog converter (DAC, D/A, D2A, or D-to-A) is a system that converts a digital signal into an analog signal. An analog-to-digital converter (ADC) performs the reverse function. There are several DAC architectures the suitability of a DAC for a particular application is determined by figures of merit including: resolution, maximum sampling frequency and others. Digital-to-analog conversion can degrade a signal, so a DAC should be specified that has insignificant errors in terms of the application. DAC \u2018s will take a digital value and convert it to an output voltage on a specified pin. Typically in the range 0v to Vcc . So for example if the Vcc was 3.3V and our digital value could be anything between 0 and 255 (8bits). Setting it to 0 would result in 0V at the output pin, a value of 127 would be approx 1.65V at the output pin and 255 would be 3.3V. In this way we could control the brightness of a light or speed of a motor by altering the voltage supplied to it using a digital number 0 for lowest value, 255 for largest and then any value in-between. We can also use PWM as well but the quality will not be same as DAC.PWM will just simulate what DAC does when it comes to audio. DAC\u2019s in particular come into their own when it comes to sound. Once your sound has been stored digitally (converted using an ADC) if you want to listen to it again with your analogue ears then we need to be able to convert it back from the digital data into a analogue signal again and hence the DAC\u2019s. Resolution and accuracy The higher the resolution then the more accurate your digital stored sound will be when replayed. Note that there are other factors to sound accuracy \u2013 such as sample rate \u2013 which we will cover in later articles on producing sound. For now we will just look at resolution. In the CD specification it was 16 bit resolution, so the original sound when converted to a voltage using a microphone was stored as a 16 bit number \u2013 a number between 0 and 65535 . The higher the number of bits to store the sound the finer and more accurate sound representation we will get. However the human ear has limitations and it\u2019s not just a matter of the more the number of bits the better the sound as there comes a point when our ears cannot tell the difference. In the ESP32 the resolution is 256, it has a 8 bit DAC (values from 0 to 255). This may seem poor but in fact it does allow us to have a good representation of sound . But With our 3.3 volts processor this should mean a 0 sent to the DAC would give 0V on the DAC output pin and 255 would give 3.3V on the DAC output pin. However in real life the circuitry gives just slightly different values for various technical reasons. Generally starting a little over 0V and ending at around 3.24V for value of 255.","title":"Introduction"},{"location":"01_introduction/#eyfi-mega-based-audio-synthesizer","text":"Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas","title":"eYFi-Mega based Audio Synthesizer"},{"location":"01_introduction/#introduction","text":"eYFi Mega based Audio Synthesizer is an Audio device project where we will create an audio synthesizer or in simple words audio generator. In this project we will be using 4x4 16 Key Universal Keypad and a speaker. Using Keypad we will generate different tones as programmed.","title":"Introduction"},{"location":"01_introduction/#eyfi-mega","text":"eYFi Mega Development board is an Atmega2560 and ESP32 based development board, made in India. This board is developed by eYantra at IIT Bombay. Key-points: Atmega2560 and ESP32 based WiFi Compatible FreeRTOS Compatible Arduino IDE suitable","title":"eYFi Mega"},{"location":"01_introduction/#audio-synthesizer","text":"A Audio Synthesizer is an electronic musical instrument that generates audio signals. Synthesizers generate audio through methods including subtractive synthesis, additive synthesis, and frequency modulation synthesis. Synthesizers are typically played with keyboards or controlled by sequencers, software, or other instruments, often via MIDI.","title":"Audio Synthesizer"},{"location":"01_introduction/#digital-signal-processing-dsp","text":"Mathematical manipulation of Digial Signals like Audio, Video, Pressure, Temperature, etc is called as Digital Signal Processing (DSP) . It is the use of digital processing, such as by computers or more specialized digital signal processors, to perform a wide variety of signal processing operations. DSP can involve linear or nonlinear operations. Nonlinear signal processing is closely related to nonlinear system identification and can be implemented in the time, frequency, and spatio-temporal domains.","title":"Digital Signal Processing (DSP)"},{"location":"01_introduction/#about-sound","text":"Sounds are just vibrations, our ears pick up the vibrations from objects as they hit the air particles in front of them and the energy is passed on; air particle to air particle; until air particles in our ear pass on this vibrating energy to our ear drum and through some other clever nature stuff we convert this to electrical signals in our ear that the brain can interpret as sound. The pitch of a sound is the speed at which it vibrates, its frequency Sounds from vibrations produce sound waves and as such like other types of wave have certain properties, they two main ones we\u2019re interested in are the frequency which is how many times is that repeated and the amplitude is how much intensity is that having .An important thing to notice about the wave is that the amplitude changes over the time . It\u2019s not instant high then instant low. We can produce sounds like this and they are called square waves but in nature this type of sound waves are rare find We are using DAC Audio library to play (sa re ga ma pa da ne sa) tones which are stored as values between 0-65535 . It uses a digital to analogue interface, which are built into the ESP32 (but not Arduino\u2019s), hence why I chose that chip for the main development. This allows the relatively precise control over the final waveform. There are other ways of getting sound out of an ESP32, such as it\u2019s in-built support for I2S streaming. With this you can output digital sound to nearly any pin and with couple or so components you can get stereo sound out. Really quite cool. In the future the library will support this approach but for now it uses the DAC pin which reduces external components (admittedly very slightly) and I think conceptually it is easier for a beginner to see how sound could be produced that way. In any case that\u2019s the way the design was originally conceived!! What is a DAC ? In electronics, a digital-to-analog converter (DAC, D/A, D2A, or D-to-A) is a system that converts a digital signal into an analog signal. An analog-to-digital converter (ADC) performs the reverse function. There are several DAC architectures the suitability of a DAC for a particular application is determined by figures of merit including: resolution, maximum sampling frequency and others. Digital-to-analog conversion can degrade a signal, so a DAC should be specified that has insignificant errors in terms of the application. DAC \u2018s will take a digital value and convert it to an output voltage on a specified pin. Typically in the range 0v to Vcc . So for example if the Vcc was 3.3V and our digital value could be anything between 0 and 255 (8bits). Setting it to 0 would result in 0V at the output pin, a value of 127 would be approx 1.65V at the output pin and 255 would be 3.3V. In this way we could control the brightness of a light or speed of a motor by altering the voltage supplied to it using a digital number 0 for lowest value, 255 for largest and then any value in-between. We can also use PWM as well but the quality will not be same as DAC.PWM will just simulate what DAC does when it comes to audio. DAC\u2019s in particular come into their own when it comes to sound. Once your sound has been stored digitally (converted using an ADC) if you want to listen to it again with your analogue ears then we need to be able to convert it back from the digital data into a analogue signal again and hence the DAC\u2019s. Resolution and accuracy The higher the resolution then the more accurate your digital stored sound will be when replayed. Note that there are other factors to sound accuracy \u2013 such as sample rate \u2013 which we will cover in later articles on producing sound. For now we will just look at resolution. In the CD specification it was 16 bit resolution, so the original sound when converted to a voltage using a microphone was stored as a 16 bit number \u2013 a number between 0 and 65535 . The higher the number of bits to store the sound the finer and more accurate sound representation we will get. However the human ear has limitations and it\u2019s not just a matter of the more the number of bits the better the sound as there comes a point when our ears cannot tell the difference. In the ESP32 the resolution is 256, it has a 8 bit DAC (values from 0 to 255). This may seem poor but in fact it does allow us to have a good representation of sound . But With our 3.3 volts processor this should mean a 0 sent to the DAC would give 0V on the DAC output pin and 255 would give 3.3V on the DAC output pin. However in real life the circuitry gives just slightly different values for various technical reasons. Generally starting a little over 0V and ending at around 3.24V for value of 255.","title":"About Sound"},{"location":"02_hardware/","text":"eYFi-Mega based Audio Synthesizer Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas Circuit Schematic Components Used 1. eYFi Mega Development Board - ATmega2560 and ESP32 based development board Arduino Programming Language Compatible Wi-Fi compatible Over-The-Air Update Bluetooth Low Energy Compatible with FreeRTOS 2. 8 Ohm 0.5W Small MINI speaker - Rated Impedance: 8 \u00e2\u00b120% \u00ee (at 1khz) 8 Ohm Resistance 0.5 W Power Rating Frequency Range: ~600-10khz Resonance Frequency (fo): 680 \u00e2\u00b120% Hz at 1V Diameter: 28mm / 1.1 3. 4x4 Universial 16 Key Keypad - Operating pressure : Touch feeling: 170 ~ 397g (6 ~ 14oz). Switch travel : Touch-type: 0.6 ~ 1.5mm. Circuit Rating : 35V (DC), 100mA, 1W. Contact resistance : 500 (\u03a9). Insulation resistance : 100M (\u03a9). Key Operating Force : 150-200N. Rebound Time : 1 (ms).","title":"Hardware"},{"location":"02_hardware/#eyfi-mega-based-audio-synthesizer","text":"Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas","title":"eYFi-Mega based Audio Synthesizer"},{"location":"02_hardware/#circuit-schematic","text":"","title":"Circuit Schematic"},{"location":"02_hardware/#components-used","text":"","title":"Components Used"},{"location":"02_hardware/#1-eyfi-mega-development-board-","text":"ATmega2560 and ESP32 based development board Arduino Programming Language Compatible Wi-Fi compatible Over-The-Air Update Bluetooth Low Energy Compatible with FreeRTOS","title":"1. eYFi Mega Development Board -"},{"location":"02_hardware/#2-8-ohm-05w-small-mini-speaker-","text":"Rated Impedance: 8 \u00e2\u00b120% \u00ee (at 1khz) 8 Ohm Resistance 0.5 W Power Rating Frequency Range: ~600-10khz Resonance Frequency (fo): 680 \u00e2\u00b120% Hz at 1V Diameter: 28mm / 1.1","title":"2. 8 Ohm 0.5W Small MINI speaker -"},{"location":"02_hardware/#3-4x4-universial-16-key-keypad-","text":"Operating pressure : Touch feeling: 170 ~ 397g (6 ~ 14oz). Switch travel : Touch-type: 0.6 ~ 1.5mm. Circuit Rating : 35V (DC), 100mA, 1W. Contact resistance : 500 (\u03a9). Insulation resistance : 100M (\u03a9). Key Operating Force : 150-200N. Rebound Time : 1 (ms).","title":"3. 4x4 Universial 16 Key Keypad -"},{"location":"03_software/","text":"eYFi-Mega based Audio Synthesizer Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas Softwares 1. Arduino IDE for E-yantra Open-source Arduino Software (IDE) Easy to write code and upload it to the board Runs on Windows, Mac OS X, and Linux Environment is written in Java Based on Processing and other open-source software. Add on for E-YFi mega board is available Here is the working of this particular software , this is very similar to arudino ide , but few changes are done so it will work with e-YFi mega boards. We can include this by adding the json link in the board manager as well This is the development Tool which we used to code and debug . We also included all necessarly libraries .","title":"Software"},{"location":"03_software/#eyfi-mega-based-audio-synthesizer","text":"Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas","title":"eYFi-Mega based Audio Synthesizer"},{"location":"03_software/#softwares","text":"","title":"Softwares"},{"location":"03_software/#1-arduino-ide-for-e-yantra","text":"Open-source Arduino Software (IDE) Easy to write code and upload it to the board Runs on Windows, Mac OS X, and Linux Environment is written in Java Based on Processing and other open-source software. Add on for E-YFi mega board is available Here is the working of this particular software , this is very similar to arudino ide , but few changes are done so it will work with e-YFi mega boards. We can include this by adding the json link in the board manager as well This is the development Tool which we used to code and debug . We also included all necessarly libraries .","title":"1. Arduino IDE for E-yantra"},{"location":"04_code/","text":"eYFi-Mega based Audio Synthesizer Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas Program For ESP 32 * Now let us see how to generate simple waves such as Square wave Triangular wave Square Wave Sawtooth Wave This code will play all of those waves on loop Audio is a way of producing realistic sounds using digital equipment or computers. In this sequence of articles we will explore the DAC Audio library for both ESP32 and Arduino systems What is Sound? Sounds are just vibrations, our ears pick up the vibrations from objects or instruments as they hit the air particles in front of them and the energy is passed on Sounds from vibrations produce sound waves and as such like other types of wave have certain properties, they two main ones we\u2019re interested in are (as already mentioned) the frequency (how often the whatever it is, is vibrating) and the amplitude (how loud the sound is). Below is an example of a simple sound wave; Next we utilized the pre-Built libraries by XT_DAC_Audio where we can play some basic tunes and melodies as well as change the Instruments , play a wave file and lot of other functionalities #define Num_Samples 112 // number of dample of signal #define MaxWaveTypes 4 // types of wave (signal) int i = 0; static byte WaveFormTable[MaxWaveTypes][Num_Samples] = { // Sin wave { 0x80, 0x83, 0x87, 0x8A, 0x8E, 0x91, 0x95, 0x98, 0x9B, 0x9E, 0xA2, 0xA5, 0xA7, 0xAA, 0xAD, 0xAF, 0xB2, 0xB4, 0xB6, 0xB8, 0xB9, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xBF, 0xBF, 0xC0, 0xBF, 0xBF, 0xBF, 0xBE, 0xBD, 0xBC, 0xBB, 0xB9, 0xB8, 0xB6, 0xB4, 0xB2, 0xAF, 0xAD, 0xAA, 0xA7, 0xA5, 0xA2, 0x9E, 0x9B, 0x98, 0x95, 0x91, 0x8E, 0x8A, 0x87, 0x83, 0x80, 0x7C, 0x78, 0x75, 0x71, 0x6E, 0x6A, 0x67, 0x64, 0x61, 0x5D, 0x5A, 0x58, 0x55, 0x52, 0x50, 0x4D, 0x4B, 0x49, 0x47, 0x46, 0x44, 0x43, 0x42, 0x41, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x41, 0x42, 0x43, 0x44, 0x46, 0x47, 0x49, 0x4B, 0x4D, 0x50, 0x52, 0x55, 0x58, 0x5A, 0x5D, 0x61, 0x64, 0x67, 0x6A, 0x6E, 0x71, 0x75, 0x78, 0x7C }, // Triangular wave table { 0x80, 0x84, 0x89, 0x8D, 0x92, 0x96, 0x9B, 0x9F, 0xA4, 0xA8, 0xAD, 0xB2, 0xB6, 0xBB, 0xBF, 0xC4, 0xC8, 0xCD, 0xD1, 0xD6, 0xDB, 0xDF, 0xE4, 0xE8, 0xED, 0xF1, 0xF6, 0xFA, 0xFF, 0xFA, 0xF6, 0xF1, 0xED, 0xE8, 0xE4, 0xDF, 0xDB, 0xD6, 0xD1, 0xCD, 0xC8, 0xC4, 0xBF, 0xBB, 0xB6, 0xB2, 0xAD, 0xA8, 0xA4, 0x9F, 0x9B, 0x96, 0x92, 0x8D, 0x89, 0x84, 0x7F, 0x7B, 0x76, 0x72, 0x6D, 0x69, 0x64, 0x60, 0x5B, 0x57, 0x52, 0x4D, 0x49, 0x44, 0x40, 0x3B, 0x37, 0x32, 0x2E, 0x29, 0x24, 0x20, 0x1B, 0x17, 0x12, 0x0E, 0x09, 0x05, 0x00, 0x05, 0x09, 0x0E, 0x12, 0x17, 0x1B, 0x20, 0x24, 0x29, 0x2E, 0x32, 0x37, 0x3B, 0x40, 0x44, 0x49, 0x4D, 0x52, 0x57, 0x5B, 0x60, 0x64, 0x69, 0x6D, 0x72, 0x76, 0x7B }, // Sawtooth wave table { 0x00, 0x02, 0x04, 0x06, 0x09, 0x0B, 0x0D, 0x10, 0x12, 0x14, 0x16, 0x19, 0x1B, 0x1D, 0x20, 0x22, 0x24, 0x27, 0x29, 0x2B, 0x2D, 0x30, 0x32, 0x34, 0x37, 0x39, 0x3B, 0x3E, 0x40, 0x42, 0x44, 0x47, 0x49, 0x4B, 0x4E, 0x50, 0x52, 0x54, 0x57, 0x59, 0x5B, 0x5E, 0x60, 0x62, 0x65, 0x67, 0x69, 0x6B, 0x6E, 0x70, 0x72, 0x75, 0x77, 0x79, 0x7C, 0x7E, 0x80, 0x82, 0x85, 0x87, 0x89, 0x8C, 0x8E, 0x90, 0x93, 0x95, 0x97, 0x99, 0x9C, 0x9E, 0xA0, 0xA3, 0xA5, 0xA7, 0xA9, 0xAC, 0xAE, 0xB0, 0xB3, 0xB5, 0xB7, 0xBA, 0xBC, 0xBE, 0xC0, 0xC3, 0xC5, 0xC7, 0xCA, 0xCC, 0xCE, 0xD1, 0xD3, 0xD5, 0xD7, 0xDA, 0xDC, 0xDE, 0xE1, 0xE3, 0xE5, 0xE8, 0xEA, 0xEC, 0xEE, 0xF1, 0xF3, 0xF5, 0xF8, 0xFA, 0xFC, 0xFE }, // Square wave table { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } }; void setup() { Serial.begin(115200); // serial monitor at 115200 bps } void loop() { for(int j=0;j<4;j++) { byte wave_type = 0; // Sine byte wave_type = 1; // Triangle byte wave_type = 2; // Sawtooth byte wave_type = 3; // Square command dacWrite(25, WaveFormTable[wave_type][i]); // output wave form i++; if (i >= Num_Samples) i = 0; } } Playing of Music tones (octaves) Now once this is done next will be the generation of music tones ( sa,re,ga,ma,pa,da,ne,sa) . so to realize that we produced the sound , then using Audacity converted the format into 8-Bit sound and stored in uncompressed manner . Then we converted raw wav file into discrete vales between 0-65565. Thus when the same is fed into DAC the same sound will be generated . All the sound information was included as a part of header file which we created called sound.h and we then associated each key pressed from keypad with each of the tone . Code for Audio Synthesis #include <Wire.h> #include \"arduinoFFT.h\" #include \"SSD1306.h\" SSD1306 display(0x3c,SDA,SCL); #define SAMPLES 512 #define SAMPLING_FREQUENCY 40000 #define amplitude 150 #include <Tone32.h> #include \"SoundData.h\" #include \"XT_DAC_Audio.h\" #define Num_Samples 112 // number of dample of signal #define MaxWaveTypes 4 // types of wave (signal) int count1 = 0; int8_t PROGMEM TwinkleTwinkle[] = { NOTE_C5,NOTE_C5,NOTE_G5,NOTE_G5,NOTE_A5,NOTE_A5,NOTE_G5,BEAT_2, NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5,BEAT_2, NOTE_G5,NOTE_G5,NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,BEAT_2, NOTE_G5,NOTE_G5,NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,BEAT_2, NOTE_C5,NOTE_C5,NOTE_G5,NOTE_G5,NOTE_A5,NOTE_A5,NOTE_G5,BEAT_2, NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5,BEAT_4, NOTE_SILENCE,BEAT_5,SCORE_END }; XT_DAC_Audio_Class DacAudio(25,0); // Create the main player class object. Use GPIO 25, one of the 2 DAC pins and timer 0 XT_Wav_Class Zero(sa); XT_Wav_Class One(re); XT_Wav_Class Two(ga); XT_Wav_Class Three(ma); XT_Wav_Class Four(pa); XT_Wav_Class Five(da); XT_Wav_Class Six(nee); XT_Wav_Class Seven(bsa); XT_Wav_Class Eight(EightWav); XT_Wav_Class Nine(NineWav); XT_Sequence_Class Sequence; // The sequence object, you add your sounds above to this object (see setup below) // Creation of FFT object for arudino arduinoFFT FFT = arduinoFFT(); unsigned int sampling_period_us; unsigned long microseconds; byte peak[] = {0,0,0,0,0,0,0}; double vReal[SAMPLES]; double vImag[SAMPLES]; unsigned long newTime, oldTime; void TaskBlink( void *pvParameters ); void TaskAnalogReadA3( void *pvParameters ); void displayBand(int band, int dsize){ int dmax = 50; if (dsize > dmax) dsize = dmax; if (band == 7) display.drawHorizontalLine(18*6,0, 14); for (int s = 0; s <= dsize; s=s+2){display.drawHorizontalLine(18*band,64-s, 14);} if (dsize > peak[band]) {peak[band] = dsize;} } void PlayNumber(char const *Number) { int NumChars=strlen(Number); // could lose this line of put strlen in loop below, but bad form to do so Sequence.RemoveAllPlayItems(); // Clear out any previous playlist for(int i=0;i<NumChars;i++) AddNumberToSequence(Number[i]); // For each number add in the sound for that number to the sequence DacAudio.Play(&Sequence); // Play the sequence, will not wait here to complete, works independently of your code Serial.println(Number); // Confirm number entered to the user over the serial } void AddNumberToSequence(char TheNumber) { // Adds in the wav for the single 0-9 number passed in as a char switch(TheNumber) { case '0' : Sequence.AddPlayItem(&Zero);break; case '1' : Sequence.AddPlayItem(&One);break; case '2' : Sequence.AddPlayItem(&Two);break; case '3' : Sequence.AddPlayItem(&Three);break; case '4' : Sequence.AddPlayItem(&Four);break; case '5' : Sequence.AddPlayItem(&Five);break; case '6' : Sequence.AddPlayItem(&Six);break; case '7' : Sequence.AddPlayItem(&Seven);break; case '8' : Sequence.AddPlayItem(&Eight);break; case '9' : Sequence.AddPlayItem(&Nine);break; } } void setup() { // initialize serial communication at 115200 bits per second: Serial.begin(115200); Serial2.begin(9600, SERIAL_8N1,16, 17); Wire.begin(5,4); // SDA, SCL display.init(); display.setFont(ArialMT_Plain_10); display.flipScreenVertically(); // Adjust to suit or remove sampling_period_us = round(1000000 * (1.0 / SAMPLING_FREQUENCY)); // Now set up two tasks to run independently. xTaskCreatePinnedToCore( TaskBlink , \"TaskBlink\" // Name of this particular task given for understanding , 1024 // This stack size can be checked & adjusted by reading the Stack Highwater , NULL , 1 // Priority , NULL , 0); xTaskCreatePinnedToCore( TaskAnalogReadA3 , \"AnalogReadA3\" , 1024 // Stack size , NULL , 2 // Priority , NULL , 1); // here select the core to which this task will be pinned // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started. } void loop() { // Empty. Things are done in Tasks. } /*-----------------------------------------------------------------------------------------------------------------*/ /*---------------------- Tasks ( Running Serial monitor and Audio synthesizer--------------------------------------*/ /*------------------------------------------------------------------------------------------------------------------*/ void TaskBlink(void *pvParameters) // This is a task. { (void) pvParameters; XT_DAC_Audio_Class DacAudio(25,0); // Create the main player class object. Use GPIO 25 (DAC pin) and timer 0 for (;;) { DacAudio.FillBuffer(); if(Serial2.available()) PlayNumber(Serial2.readString().c_str()); vTaskDelay(10); } } /*-----------------------------------------------------------------------------------------------------------------*/ /*---------------------- Tasks ( Running DSP algorithm for FFT generation and Running audio Synthesizer---------------------*/ /*------------------------------------------------------------------------------------------------------------------*/ void TaskAnalogReadA3(void *pvParameters) // This is a task for spectrum analyzer { (void) pvParameters; for (;;) { Serial.println(\"SPECTRUM\"); display.clear(); display.drawString(0,0,\"0.1 0.2 0.5 1K 2K 4K 8K\"); for (int i = 0; i < SAMPLES; i++) { newTime = micros()-oldTime; oldTime = newTime; vReal[i] = analogRead(A0); // A conversion takes about 1uS on an ESP32 vImag[i] = 0; while (micros() < (newTime + sampling_period_us)) { /* do nothing to wait */ } } FFT.Windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD); FFT.Compute(vReal, vImag, SAMPLES, FFT_FORWARD); FFT.ComplexToMagnitude(vReal, vImag, SAMPLES); for (int i = 2; i < (SAMPLES/2); i++){ // Don't use sample 0 and only first SAMPLES/2 are usable. Each array eleement represents a frequency and its value the amplitude. if (vReal[i] > 2000) { // Add a crude noise filter, 10 x amplitude or more if (i<=2 ) displayBand(0,(int)vReal[i]/amplitude); // 125Hz if (i >3 && i<=5 ) displayBand(1,(int)vReal[i]/amplitude); // 250Hz if (i >5 && i<=7 ) displayBand(2,(int)vReal[i]/amplitude); // 500Hz if (i >7 && i<=15 ) displayBand(3,(int)vReal[i]/amplitude); // 1000Hz if (i >15 && i<=30 ) displayBand(4,(int)vReal[i]/amplitude); // 2000Hz if (i >30 && i<=53 ) displayBand(5,(int)vReal[i]/amplitude); // 4000Hz if (i >53 && i<=200 ) displayBand(6,(int)vReal[i]/amplitude); // 8000Hz if (i >200 ) displayBand(7,(int)vReal[i]/amplitude); // 16000Hz } for (byte band = 0; band <= 6; band++) display.drawHorizontalLine(18*band,64-peak[band],14); } if (millis()%4 == 0) {for (byte band = 0; band <= 6; band++) {if (peak[band] > 0) peak[band] -= 1;}} // Decay the peak display.display(); vTaskDelay(10); } } Here in the above code was uploaded as a part of ESP 32 and we wrote separate code was uploaded on Atmega 2560 to monitor the keypad constantly and then send an intimation over serial lines to ESP32 whenever a key was pressed . Code for Atmega 2560 #include <Keypad.h> const byte ROWS = 4; //four rows const byte COLS = 4; //three columns char keys[ROWS][COLS] = { {'1','2','3','A'}, {'4','5','6','B'}, {'7','8','9','C'}, {'*','0','#','D'} }; byte rowPins[ROWS] = {5,7,9,11}; //connect to the row pinouts of the keypad byte colPins[COLS] = {4,46,44,6}; //connect to the column pinouts of the keypad Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS ); byte ledPin = 13; boolean ledPin_state; void setup(){ Serial.begin(9600); Serial1.begin(9600); pinMode(ledPin, OUTPUT); // Sets the digital pin as output. digitalWrite(ledPin, HIGH); // Turn the LED on. ledPin_state = digitalRead(ledPin); // Store initial LED state. HIGH when LED is on. keypad.addEventListener(keypadEvent); // Add an event listener for this keypad } void loop(){ char key = keypad.getKey(); if (key) { Serial1.write(key); Serial.println(key); } } // Taking care of some special events. void keypadEvent(KeypadEvent key){ switch (keypad.getkey()){ case PRESSED: { if (key == '#') { digitalWrite(ledPin,!digitalRead(ledPin)); ledPin_state = digitalRead(ledPin); // Remember LED state, lit or unlit. } break; } }","title":"**eYFi-Mega based Audio Synthesizer**"},{"location":"04_code/#eyfi-mega-based-audio-synthesizer","text":"Mentor(s) : Sourav, Prasad, eYRDC Interns : Aravinda Harithsa, Marefat Abbas","title":"eYFi-Mega based Audio Synthesizer"},{"location":"04_code/#program-for-esp-32","text":"Now let us see how to generate simple waves such as Square wave Triangular wave Square Wave Sawtooth Wave This code will play all of those waves on loop Audio is a way of producing realistic sounds using digital equipment or computers. In this sequence of articles we will explore the DAC Audio library for both ESP32 and Arduino systems What is Sound? Sounds are just vibrations, our ears pick up the vibrations from objects or instruments as they hit the air particles in front of them and the energy is passed on Sounds from vibrations produce sound waves and as such like other types of wave have certain properties, they two main ones we\u2019re interested in are (as already mentioned) the frequency (how often the whatever it is, is vibrating) and the amplitude (how loud the sound is). Below is an example of a simple sound wave; Next we utilized the pre-Built libraries by XT_DAC_Audio where we can play some basic tunes and melodies as well as change the Instruments , play a wave file and lot of other functionalities #define Num_Samples 112 // number of dample of signal #define MaxWaveTypes 4 // types of wave (signal) int i = 0; static byte WaveFormTable[MaxWaveTypes][Num_Samples] = { // Sin wave { 0x80, 0x83, 0x87, 0x8A, 0x8E, 0x91, 0x95, 0x98, 0x9B, 0x9E, 0xA2, 0xA5, 0xA7, 0xAA, 0xAD, 0xAF, 0xB2, 0xB4, 0xB6, 0xB8, 0xB9, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xBF, 0xBF, 0xC0, 0xBF, 0xBF, 0xBF, 0xBE, 0xBD, 0xBC, 0xBB, 0xB9, 0xB8, 0xB6, 0xB4, 0xB2, 0xAF, 0xAD, 0xAA, 0xA7, 0xA5, 0xA2, 0x9E, 0x9B, 0x98, 0x95, 0x91, 0x8E, 0x8A, 0x87, 0x83, 0x80, 0x7C, 0x78, 0x75, 0x71, 0x6E, 0x6A, 0x67, 0x64, 0x61, 0x5D, 0x5A, 0x58, 0x55, 0x52, 0x50, 0x4D, 0x4B, 0x49, 0x47, 0x46, 0x44, 0x43, 0x42, 0x41, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x41, 0x42, 0x43, 0x44, 0x46, 0x47, 0x49, 0x4B, 0x4D, 0x50, 0x52, 0x55, 0x58, 0x5A, 0x5D, 0x61, 0x64, 0x67, 0x6A, 0x6E, 0x71, 0x75, 0x78, 0x7C }, // Triangular wave table { 0x80, 0x84, 0x89, 0x8D, 0x92, 0x96, 0x9B, 0x9F, 0xA4, 0xA8, 0xAD, 0xB2, 0xB6, 0xBB, 0xBF, 0xC4, 0xC8, 0xCD, 0xD1, 0xD6, 0xDB, 0xDF, 0xE4, 0xE8, 0xED, 0xF1, 0xF6, 0xFA, 0xFF, 0xFA, 0xF6, 0xF1, 0xED, 0xE8, 0xE4, 0xDF, 0xDB, 0xD6, 0xD1, 0xCD, 0xC8, 0xC4, 0xBF, 0xBB, 0xB6, 0xB2, 0xAD, 0xA8, 0xA4, 0x9F, 0x9B, 0x96, 0x92, 0x8D, 0x89, 0x84, 0x7F, 0x7B, 0x76, 0x72, 0x6D, 0x69, 0x64, 0x60, 0x5B, 0x57, 0x52, 0x4D, 0x49, 0x44, 0x40, 0x3B, 0x37, 0x32, 0x2E, 0x29, 0x24, 0x20, 0x1B, 0x17, 0x12, 0x0E, 0x09, 0x05, 0x00, 0x05, 0x09, 0x0E, 0x12, 0x17, 0x1B, 0x20, 0x24, 0x29, 0x2E, 0x32, 0x37, 0x3B, 0x40, 0x44, 0x49, 0x4D, 0x52, 0x57, 0x5B, 0x60, 0x64, 0x69, 0x6D, 0x72, 0x76, 0x7B }, // Sawtooth wave table { 0x00, 0x02, 0x04, 0x06, 0x09, 0x0B, 0x0D, 0x10, 0x12, 0x14, 0x16, 0x19, 0x1B, 0x1D, 0x20, 0x22, 0x24, 0x27, 0x29, 0x2B, 0x2D, 0x30, 0x32, 0x34, 0x37, 0x39, 0x3B, 0x3E, 0x40, 0x42, 0x44, 0x47, 0x49, 0x4B, 0x4E, 0x50, 0x52, 0x54, 0x57, 0x59, 0x5B, 0x5E, 0x60, 0x62, 0x65, 0x67, 0x69, 0x6B, 0x6E, 0x70, 0x72, 0x75, 0x77, 0x79, 0x7C, 0x7E, 0x80, 0x82, 0x85, 0x87, 0x89, 0x8C, 0x8E, 0x90, 0x93, 0x95, 0x97, 0x99, 0x9C, 0x9E, 0xA0, 0xA3, 0xA5, 0xA7, 0xA9, 0xAC, 0xAE, 0xB0, 0xB3, 0xB5, 0xB7, 0xBA, 0xBC, 0xBE, 0xC0, 0xC3, 0xC5, 0xC7, 0xCA, 0xCC, 0xCE, 0xD1, 0xD3, 0xD5, 0xD7, 0xDA, 0xDC, 0xDE, 0xE1, 0xE3, 0xE5, 0xE8, 0xEA, 0xEC, 0xEE, 0xF1, 0xF3, 0xF5, 0xF8, 0xFA, 0xFC, 0xFE }, // Square wave table { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } }; void setup() { Serial.begin(115200); // serial monitor at 115200 bps } void loop() { for(int j=0;j<4;j++) { byte wave_type = 0; // Sine byte wave_type = 1; // Triangle byte wave_type = 2; // Sawtooth byte wave_type = 3; // Square command dacWrite(25, WaveFormTable[wave_type][i]); // output wave form i++; if (i >= Num_Samples) i = 0; } }","title":"Program For ESP 32*"},{"location":"04_code/#playing-of-music-tones-octaves","text":"Now once this is done next will be the generation of music tones ( sa,re,ga,ma,pa,da,ne,sa) . so to realize that we produced the sound , then using Audacity converted the format into 8-Bit sound and stored in uncompressed manner . Then we converted raw wav file into discrete vales between 0-65565. Thus when the same is fed into DAC the same sound will be generated . All the sound information was included as a part of header file which we created called sound.h and we then associated each key pressed from keypad with each of the tone .","title":"Playing of Music tones (octaves)"},{"location":"04_code/#code-for-audio-synthesis","text":"#include <Wire.h> #include \"arduinoFFT.h\" #include \"SSD1306.h\" SSD1306 display(0x3c,SDA,SCL); #define SAMPLES 512 #define SAMPLING_FREQUENCY 40000 #define amplitude 150 #include <Tone32.h> #include \"SoundData.h\" #include \"XT_DAC_Audio.h\" #define Num_Samples 112 // number of dample of signal #define MaxWaveTypes 4 // types of wave (signal) int count1 = 0; int8_t PROGMEM TwinkleTwinkle[] = { NOTE_C5,NOTE_C5,NOTE_G5,NOTE_G5,NOTE_A5,NOTE_A5,NOTE_G5,BEAT_2, NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5,BEAT_2, NOTE_G5,NOTE_G5,NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,BEAT_2, NOTE_G5,NOTE_G5,NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,BEAT_2, NOTE_C5,NOTE_C5,NOTE_G5,NOTE_G5,NOTE_A5,NOTE_A5,NOTE_G5,BEAT_2, NOTE_F5,NOTE_F5,NOTE_E5,NOTE_E5,NOTE_D5,NOTE_D5,NOTE_C5,BEAT_4, NOTE_SILENCE,BEAT_5,SCORE_END }; XT_DAC_Audio_Class DacAudio(25,0); // Create the main player class object. Use GPIO 25, one of the 2 DAC pins and timer 0 XT_Wav_Class Zero(sa); XT_Wav_Class One(re); XT_Wav_Class Two(ga); XT_Wav_Class Three(ma); XT_Wav_Class Four(pa); XT_Wav_Class Five(da); XT_Wav_Class Six(nee); XT_Wav_Class Seven(bsa); XT_Wav_Class Eight(EightWav); XT_Wav_Class Nine(NineWav); XT_Sequence_Class Sequence; // The sequence object, you add your sounds above to this object (see setup below) // Creation of FFT object for arudino arduinoFFT FFT = arduinoFFT(); unsigned int sampling_period_us; unsigned long microseconds; byte peak[] = {0,0,0,0,0,0,0}; double vReal[SAMPLES]; double vImag[SAMPLES]; unsigned long newTime, oldTime; void TaskBlink( void *pvParameters ); void TaskAnalogReadA3( void *pvParameters ); void displayBand(int band, int dsize){ int dmax = 50; if (dsize > dmax) dsize = dmax; if (band == 7) display.drawHorizontalLine(18*6,0, 14); for (int s = 0; s <= dsize; s=s+2){display.drawHorizontalLine(18*band,64-s, 14);} if (dsize > peak[band]) {peak[band] = dsize;} } void PlayNumber(char const *Number) { int NumChars=strlen(Number); // could lose this line of put strlen in loop below, but bad form to do so Sequence.RemoveAllPlayItems(); // Clear out any previous playlist for(int i=0;i<NumChars;i++) AddNumberToSequence(Number[i]); // For each number add in the sound for that number to the sequence DacAudio.Play(&Sequence); // Play the sequence, will not wait here to complete, works independently of your code Serial.println(Number); // Confirm number entered to the user over the serial } void AddNumberToSequence(char TheNumber) { // Adds in the wav for the single 0-9 number passed in as a char switch(TheNumber) { case '0' : Sequence.AddPlayItem(&Zero);break; case '1' : Sequence.AddPlayItem(&One);break; case '2' : Sequence.AddPlayItem(&Two);break; case '3' : Sequence.AddPlayItem(&Three);break; case '4' : Sequence.AddPlayItem(&Four);break; case '5' : Sequence.AddPlayItem(&Five);break; case '6' : Sequence.AddPlayItem(&Six);break; case '7' : Sequence.AddPlayItem(&Seven);break; case '8' : Sequence.AddPlayItem(&Eight);break; case '9' : Sequence.AddPlayItem(&Nine);break; } } void setup() { // initialize serial communication at 115200 bits per second: Serial.begin(115200); Serial2.begin(9600, SERIAL_8N1,16, 17); Wire.begin(5,4); // SDA, SCL display.init(); display.setFont(ArialMT_Plain_10); display.flipScreenVertically(); // Adjust to suit or remove sampling_period_us = round(1000000 * (1.0 / SAMPLING_FREQUENCY)); // Now set up two tasks to run independently. xTaskCreatePinnedToCore( TaskBlink , \"TaskBlink\" // Name of this particular task given for understanding , 1024 // This stack size can be checked & adjusted by reading the Stack Highwater , NULL , 1 // Priority , NULL , 0); xTaskCreatePinnedToCore( TaskAnalogReadA3 , \"AnalogReadA3\" , 1024 // Stack size , NULL , 2 // Priority , NULL , 1); // here select the core to which this task will be pinned // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started. } void loop() { // Empty. Things are done in Tasks. } /*-----------------------------------------------------------------------------------------------------------------*/ /*---------------------- Tasks ( Running Serial monitor and Audio synthesizer--------------------------------------*/ /*------------------------------------------------------------------------------------------------------------------*/ void TaskBlink(void *pvParameters) // This is a task. { (void) pvParameters; XT_DAC_Audio_Class DacAudio(25,0); // Create the main player class object. Use GPIO 25 (DAC pin) and timer 0 for (;;) { DacAudio.FillBuffer(); if(Serial2.available()) PlayNumber(Serial2.readString().c_str()); vTaskDelay(10); } } /*-----------------------------------------------------------------------------------------------------------------*/ /*---------------------- Tasks ( Running DSP algorithm for FFT generation and Running audio Synthesizer---------------------*/ /*------------------------------------------------------------------------------------------------------------------*/ void TaskAnalogReadA3(void *pvParameters) // This is a task for spectrum analyzer { (void) pvParameters; for (;;) { Serial.println(\"SPECTRUM\"); display.clear(); display.drawString(0,0,\"0.1 0.2 0.5 1K 2K 4K 8K\"); for (int i = 0; i < SAMPLES; i++) { newTime = micros()-oldTime; oldTime = newTime; vReal[i] = analogRead(A0); // A conversion takes about 1uS on an ESP32 vImag[i] = 0; while (micros() < (newTime + sampling_period_us)) { /* do nothing to wait */ } } FFT.Windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD); FFT.Compute(vReal, vImag, SAMPLES, FFT_FORWARD); FFT.ComplexToMagnitude(vReal, vImag, SAMPLES); for (int i = 2; i < (SAMPLES/2); i++){ // Don't use sample 0 and only first SAMPLES/2 are usable. Each array eleement represents a frequency and its value the amplitude. if (vReal[i] > 2000) { // Add a crude noise filter, 10 x amplitude or more if (i<=2 ) displayBand(0,(int)vReal[i]/amplitude); // 125Hz if (i >3 && i<=5 ) displayBand(1,(int)vReal[i]/amplitude); // 250Hz if (i >5 && i<=7 ) displayBand(2,(int)vReal[i]/amplitude); // 500Hz if (i >7 && i<=15 ) displayBand(3,(int)vReal[i]/amplitude); // 1000Hz if (i >15 && i<=30 ) displayBand(4,(int)vReal[i]/amplitude); // 2000Hz if (i >30 && i<=53 ) displayBand(5,(int)vReal[i]/amplitude); // 4000Hz if (i >53 && i<=200 ) displayBand(6,(int)vReal[i]/amplitude); // 8000Hz if (i >200 ) displayBand(7,(int)vReal[i]/amplitude); // 16000Hz } for (byte band = 0; band <= 6; band++) display.drawHorizontalLine(18*band,64-peak[band],14); } if (millis()%4 == 0) {for (byte band = 0; band <= 6; band++) {if (peak[band] > 0) peak[band] -= 1;}} // Decay the peak display.display(); vTaskDelay(10); } } Here in the above code was uploaded as a part of ESP 32 and we wrote separate code was uploaded on Atmega 2560 to monitor the keypad constantly and then send an intimation over serial lines to ESP32 whenever a key was pressed .","title":"Code for Audio Synthesis"},{"location":"04_code/#code-for-atmega-2560","text":"#include <Keypad.h> const byte ROWS = 4; //four rows const byte COLS = 4; //three columns char keys[ROWS][COLS] = { {'1','2','3','A'}, {'4','5','6','B'}, {'7','8','9','C'}, {'*','0','#','D'} }; byte rowPins[ROWS] = {5,7,9,11}; //connect to the row pinouts of the keypad byte colPins[COLS] = {4,46,44,6}; //connect to the column pinouts of the keypad Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS ); byte ledPin = 13; boolean ledPin_state; void setup(){ Serial.begin(9600); Serial1.begin(9600); pinMode(ledPin, OUTPUT); // Sets the digital pin as output. digitalWrite(ledPin, HIGH); // Turn the LED on. ledPin_state = digitalRead(ledPin); // Store initial LED state. HIGH when LED is on. keypad.addEventListener(keypadEvent); // Add an event listener for this keypad } void loop(){ char key = keypad.getKey(); if (key) { Serial1.write(key); Serial.println(key); } } // Taking care of some special events. void keypadEvent(KeypadEvent key){ switch (keypad.getkey()){ case PRESSED: { if (key == '#') { digitalWrite(ledPin,!digitalRead(ledPin)); ledPin_state = digitalRead(ledPin); // Remember LED state, lit or unlit. } break; } }","title":"Code for Atmega 2560"}]}